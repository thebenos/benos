{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the BenOS documentation What is BenOS? BenOS is a small, hand-written, free and open-source 64-bit operating system currently under active development. The goal of BenOS is not to become the new most used operating system in the world but to work. If it works, then it's good. Features 64-bit x86_64 kernel PS/2 keyboard support Basic text console UEFI boot via OVMF ISO generation support Repository structure Note: a branch marked as \u26a0\ufe0f will maybe get removed or replaced soon. This repository is very simple. It contains 3 branches: Main (the last stable version) Indev (the last unstable version) \u26a0\ufe0f Tofix (broken/buggy code that needs fixes) \u26a0\ufe0f Every stable versions (and unstable versions since the 0.0.9-Indev1) can be downloaded as raw images (excepted after the 0.0.9-Indev2, which provides an ISO file) directly from the (releases)[https://github.com/thebenos/benos/releases]. Project structure docs/ : the website code kernel/ : the kernel source code GNUmakefile : main build system iso.sh : ISO creation script Programming languages BenOS uses the following programming languages: C BASH GNU make x86_64 NASM How to build Building BenOS is a very simple process. Before building Make sure you have the following tools installed on your system: a C compiler (gcc/clang) ld nasm xorriso (for ISO creation) Build instructions Clone the repository: git clone https://github.com/thebenos/benos Build the OS: make all chmod +x iso.sh ./iso.sh Congratulations! benos.iso should appear in the root folder. How to run BenOS has not been tested on real hardware yet! You can run BenOS in an emulator. In this example, we will use qemu (from scripts/ ). qemu-system-x86_64 -m 512 -cdrom benos.iso -bios /usr/share/OVMF/OVMF_CODE.fd Make sure OVMF is installed if you are using UEFI. How to contribute If you want to contribute to the project, please read CONTRIBUTING.md first! License BenOS is licensed under the MIT license .","title":"Home"},{"location":"#welcome-to-the-benos-documentation","text":"","title":"Welcome to the BenOS documentation"},{"location":"#what-is-benos","text":"BenOS is a small, hand-written, free and open-source 64-bit operating system currently under active development. The goal of BenOS is not to become the new most used operating system in the world but to work. If it works, then it's good.","title":"What is BenOS?"},{"location":"#features","text":"64-bit x86_64 kernel PS/2 keyboard support Basic text console UEFI boot via OVMF ISO generation support","title":"Features"},{"location":"#repository-structure","text":"Note: a branch marked as \u26a0\ufe0f will maybe get removed or replaced soon. This repository is very simple. It contains 3 branches: Main (the last stable version) Indev (the last unstable version) \u26a0\ufe0f Tofix (broken/buggy code that needs fixes) \u26a0\ufe0f Every stable versions (and unstable versions since the 0.0.9-Indev1) can be downloaded as raw images (excepted after the 0.0.9-Indev2, which provides an ISO file) directly from the (releases)[https://github.com/thebenos/benos/releases].","title":"Repository structure"},{"location":"#project-structure","text":"docs/ : the website code kernel/ : the kernel source code GNUmakefile : main build system iso.sh : ISO creation script","title":"Project structure"},{"location":"#programming-languages","text":"BenOS uses the following programming languages: C BASH GNU make x86_64 NASM","title":"Programming languages"},{"location":"#how-to-build","text":"Building BenOS is a very simple process.","title":"How to build"},{"location":"#before-building","text":"Make sure you have the following tools installed on your system: a C compiler (gcc/clang) ld nasm xorriso (for ISO creation)","title":"Before building"},{"location":"#build-instructions","text":"Clone the repository: git clone https://github.com/thebenos/benos Build the OS: make all chmod +x iso.sh ./iso.sh Congratulations! benos.iso should appear in the root folder.","title":"Build instructions"},{"location":"#how-to-run","text":"BenOS has not been tested on real hardware yet! You can run BenOS in an emulator. In this example, we will use qemu (from scripts/ ). qemu-system-x86_64 -m 512 -cdrom benos.iso -bios /usr/share/OVMF/OVMF_CODE.fd Make sure OVMF is installed if you are using UEFI.","title":"How to run"},{"location":"#how-to-contribute","text":"If you want to contribute to the project, please read CONTRIBUTING.md first!","title":"How to contribute"},{"location":"#license","text":"BenOS is licensed under the MIT license .","title":"License"},{"location":"contributing/","text":"Contributing to BenOS Thanks for your interest in contributing to BenOS ! Everyone is welcome to contribute \u2014 the code is licensed under the MIT License . What Does \"Contributing\" Mean? Contributing means helping to improve the project in any way: fixing bugs, adding features, improving documentation, or optimizing the build system \u2014 everything counts! To keep things organized, please follow the procedures below. Contributing to the Operating System Fork the repository (preferably from the indev branch). Make your changes \u2014 you can add, fix, or modify anything, as long as the license is respected. Test your code as thoroughly as possible. Submit a pull request to the indev branch. Be sure to include a clear description of all the changes you made. Contributing to the Website Fork the repository. Make your changes inside the /docs directory. Please prioritize English for all content, even if other languages may be added later. Submit a pull request to the indev branch, and describe the changes you made. Additional Information If your pull request is accepted and you are part of the official BenOS Discord server, you will receive the BenOS Contributor role. Please only submit changes to the indev branch . Pull requests to main will not be accepted unless indev is marked as finished. Thank you again for your interest in BenOS \u2014 your contribution is greatly appreciated!","title":"Contributing"},{"location":"contributing/#contributing-to-benos","text":"Thanks for your interest in contributing to BenOS ! Everyone is welcome to contribute \u2014 the code is licensed under the MIT License .","title":"Contributing to BenOS"},{"location":"contributing/#what-does-contributing-mean","text":"Contributing means helping to improve the project in any way: fixing bugs, adding features, improving documentation, or optimizing the build system \u2014 everything counts! To keep things organized, please follow the procedures below.","title":"What Does \"Contributing\" Mean?"},{"location":"contributing/#contributing-to-the-operating-system","text":"Fork the repository (preferably from the indev branch). Make your changes \u2014 you can add, fix, or modify anything, as long as the license is respected. Test your code as thoroughly as possible. Submit a pull request to the indev branch. Be sure to include a clear description of all the changes you made.","title":"Contributing to the Operating System"},{"location":"contributing/#contributing-to-the-website","text":"Fork the repository. Make your changes inside the /docs directory. Please prioritize English for all content, even if other languages may be added later. Submit a pull request to the indev branch, and describe the changes you made.","title":"Contributing to the Website"},{"location":"contributing/#additional-information","text":"If your pull request is accepted and you are part of the official BenOS Discord server, you will receive the BenOS Contributor role. Please only submit changes to the indev branch . Pull requests to main will not be accepted unless indev is marked as finished. Thank you again for your interest in BenOS \u2014 your contribution is greatly appreciated!","title":"Additional Information"},{"location":"download/","text":"Download BenOS Download the 10 last stable BenOS versions here: LATEST RELEASE BenOS version 0.1.0 - ISO BenOS version 0.0.9 - ISO BenOS version 0.0.8 - Floppy image BenOS version 0.0.7 - Floppy image BenOS version 0.0.6 - Floppy image BenOS version 0.0.5 - Floppy image BenOS version 0.0.4 - Floppy image BenOS version 0.0.3 - Floppy image BenOS version 0.0.2 - Floppy image BenOS version 0.0.1 - Floppy image If you are looking for an older or unstable version, check out the releases section on GitHub!","title":"Download"},{"location":"download/#download-benos","text":"Download the 10 last stable BenOS versions here: LATEST RELEASE BenOS version 0.1.0 - ISO BenOS version 0.0.9 - ISO BenOS version 0.0.8 - Floppy image BenOS version 0.0.7 - Floppy image BenOS version 0.0.6 - Floppy image BenOS version 0.0.5 - Floppy image BenOS version 0.0.4 - Floppy image BenOS version 0.0.3 - Floppy image BenOS version 0.0.2 - Floppy image BenOS version 0.0.1 - Floppy image If you are looking for an older or unstable version, check out the releases section on GitHub!","title":"Download BenOS"},{"location":"license/","text":"License Copyright 2025 Wither__ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"Copyright 2025 Wither__ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/console/","text":"Console Overview The BenOS text console uses the Limine framebuffer and a .psf font to display text. Related files kernel/display/include/console.h kernel/display/include/colors.h kernel/display/include/chars.h kernel/display/console.c Constants There are 32 constants for colors in kernel/display/include/colors.h and 5 constants for special characters in kernel/display/include/chars.h . The constants defined in kernel/display/include/console.h are: PSF1_FONT_MAGIC and PSF_FONT_MAGIC: magic values used for PSF parser PIXEL: also used in the PSF parser FONT_SIZE: the size of the used font CONSOLE_WIDTH and CONSOLE_HEIGHT: the size of the console (80x25) Structures // Source: kernel/display/include/console.h // Structure of a PSF1 header typedef struct { uint16_t magic; uint8_t font_mode; uint8_t char_size; } __attribute__ ((packed)) PSF1_header; // Structure of a PSF font typedef struct { uint32_t magic; uint32_t version; uint32_t header_size; uint32_t flags; uint32_t numglyph; uint32_t bytes_per_glyph; uint32_t height; uint32_t width; } __attribute__ ((packed)) PSF_font; Enums typedef enum { SCROLLUP, SCROLLDOWN } ScrollModes; This enum is used by the console_scroll() function explained below. Functions // Source: kernel/display/include/console.h void console_advance_cursor(); This function advances of 1 character the cursor in the console. // Source: kernel/display/include/console.h void console_putchar(unsigned short int c, int *cx, int *cy, uint32_t fg, uint32_t bg); This function displays a character c at the given position cx,cy with the colors fg and bg . // Source: kernel/display/include/console.h void console_writestr(const char *s, uint32_t fg, uint32_t bg); This function displays a string s in the console with the colors fg and bg . // Source: kernel/display/include/console.h void console_writehex(uint64_t n, uint32_t fg, uint32_t bg); This function displays an hexadecimal value n in the console with the colors fg and bg . // Source: kernel/display/include/console.h void console_memdump(uint8_t *address, size_t length, uint32_t fg, uint32_t bg); This function displays length bytes from a memory address address in the console with the colors fg and bg . // Source: kernel/display/include/console.h void console_scroll(ScrollModes mode, int n, uint32_t bg); This function scrolls up or down (depending of the given ScrollMode) in the console. The new lines will get the colors fg and bg .","title":"Console"},{"location":"api/console/#console","text":"","title":"Console"},{"location":"api/console/#overview","text":"The BenOS text console uses the Limine framebuffer and a .psf font to display text.","title":"Overview"},{"location":"api/console/#related-files","text":"kernel/display/include/console.h kernel/display/include/colors.h kernel/display/include/chars.h kernel/display/console.c","title":"Related files"},{"location":"api/console/#constants","text":"There are 32 constants for colors in kernel/display/include/colors.h and 5 constants for special characters in kernel/display/include/chars.h . The constants defined in kernel/display/include/console.h are: PSF1_FONT_MAGIC and PSF_FONT_MAGIC: magic values used for PSF parser PIXEL: also used in the PSF parser FONT_SIZE: the size of the used font CONSOLE_WIDTH and CONSOLE_HEIGHT: the size of the console (80x25)","title":"Constants"},{"location":"api/console/#structures","text":"// Source: kernel/display/include/console.h // Structure of a PSF1 header typedef struct { uint16_t magic; uint8_t font_mode; uint8_t char_size; } __attribute__ ((packed)) PSF1_header; // Structure of a PSF font typedef struct { uint32_t magic; uint32_t version; uint32_t header_size; uint32_t flags; uint32_t numglyph; uint32_t bytes_per_glyph; uint32_t height; uint32_t width; } __attribute__ ((packed)) PSF_font;","title":"Structures"},{"location":"api/console/#enums","text":"typedef enum { SCROLLUP, SCROLLDOWN } ScrollModes; This enum is used by the console_scroll() function explained below.","title":"Enums"},{"location":"api/console/#functions","text":"// Source: kernel/display/include/console.h void console_advance_cursor(); This function advances of 1 character the cursor in the console. // Source: kernel/display/include/console.h void console_putchar(unsigned short int c, int *cx, int *cy, uint32_t fg, uint32_t bg); This function displays a character c at the given position cx,cy with the colors fg and bg . // Source: kernel/display/include/console.h void console_writestr(const char *s, uint32_t fg, uint32_t bg); This function displays a string s in the console with the colors fg and bg . // Source: kernel/display/include/console.h void console_writehex(uint64_t n, uint32_t fg, uint32_t bg); This function displays an hexadecimal value n in the console with the colors fg and bg . // Source: kernel/display/include/console.h void console_memdump(uint8_t *address, size_t length, uint32_t fg, uint32_t bg); This function displays length bytes from a memory address address in the console with the colors fg and bg . // Source: kernel/display/include/console.h void console_scroll(ScrollModes mode, int n, uint32_t bg); This function scrolls up or down (depending of the given ScrollMode) in the console. The new lines will get the colors fg and bg .","title":"Functions"},{"location":"api/io/","text":"I/O - Inputs/Outputs Overview I/O ports (Input/Output ports) are special hardware addresses used to communicate directly with devices via the x86 port-mapped I/O mechanism. Unlike memory-mapped registers, I/O ports are accessed using dedicated CPU instructions like in and out. In BenOS, I/O ports are used to control and read data from low-level hardware components such as: the PIT (Programmable Interval Timer), the PIC (Programmable Interrupt Controller), the PS/2 controller, and other similar hardware interfaces. Functions like inb() , outb() , etc., provide simple wrappers to perform byte access to these ports. Related files kernel/cpu/include/io.h kernel/cpu/io.c Functions There are actually three functions used to access I/O ports. // Source: kernel/cpu/include/io.h void outb(uint16_t port, uint8_t value); uint8_t inb(uint16_t port); void io_wait(); outb() sends a given byte to a given port. inb() : receives a byte from a given port. io_wait() : creates a delay by sending an information to a port.","title":"IO ports"},{"location":"api/io/#io-inputsoutputs","text":"","title":"I/O - Inputs/Outputs"},{"location":"api/io/#overview","text":"I/O ports (Input/Output ports) are special hardware addresses used to communicate directly with devices via the x86 port-mapped I/O mechanism. Unlike memory-mapped registers, I/O ports are accessed using dedicated CPU instructions like in and out. In BenOS, I/O ports are used to control and read data from low-level hardware components such as: the PIT (Programmable Interval Timer), the PIC (Programmable Interrupt Controller), the PS/2 controller, and other similar hardware interfaces. Functions like inb() , outb() , etc., provide simple wrappers to perform byte access to these ports.","title":"Overview"},{"location":"api/io/#related-files","text":"kernel/cpu/include/io.h kernel/cpu/io.c","title":"Related files"},{"location":"api/io/#functions","text":"There are actually three functions used to access I/O ports. // Source: kernel/cpu/include/io.h void outb(uint16_t port, uint8_t value); uint8_t inb(uint16_t port); void io_wait(); outb() sends a given byte to a given port. inb() : receives a byte from a given port. io_wait() : creates a delay by sending an information to a port.","title":"Functions"},{"location":"api/lib/","text":"Kernel library Overview The kernel library is a small and lite collection of useful functions for kernel parts, like basic memory management. Related files kernel/include/lib.h kernel/lib.c Library functions memcpy // Source: kernel/include/lib.h void *memcpy(void *dest, const void *src, size_t n); This functions copies n bytes from src to dest . memset // Source: kernel/include/lib.h void *memset(void *s, int c, size_t n); This function sets n bytes of s to c . memmove // Source: kernel/include/lib.h void *memmove(void *dest, const void *src, size_t n); This function moves n bytes from src to dest . memcmp // Source: kernel/include/lib.h int memcmp(void *s1, const void *s2, size_t n); This function compares n bytes between s1 and s2 .","title":"Kernel library"},{"location":"api/lib/#kernel-library","text":"","title":"Kernel library"},{"location":"api/lib/#overview","text":"The kernel library is a small and lite collection of useful functions for kernel parts, like basic memory management.","title":"Overview"},{"location":"api/lib/#related-files","text":"kernel/include/lib.h kernel/lib.c","title":"Related files"},{"location":"api/lib/#library-functions","text":"memcpy // Source: kernel/include/lib.h void *memcpy(void *dest, const void *src, size_t n); This functions copies n bytes from src to dest . memset // Source: kernel/include/lib.h void *memset(void *s, int c, size_t n); This function sets n bytes of s to c . memmove // Source: kernel/include/lib.h void *memmove(void *dest, const void *src, size_t n); This function moves n bytes from src to dest . memcmp // Source: kernel/include/lib.h int memcmp(void *s1, const void *s2, size_t n); This function compares n bytes between s1 and s2 .","title":"Library functions"},{"location":"cpu/gdt/","text":"GDT \u2013 Global Descriptor Table This page documents the internal implementation of the GDT setup in BenOS. Overview The GDT is initialized during early kernel boot to setup required segment descriptors in long mode. The segmentation is not really used in long mode, but the GDT is still required for compatibility and TSS loading. Related files: kernel/cpu/include.gdt.h kernel/cpu/gdt.c kernel/asm/gdt_flush.asm Responsibilities The GDT setup code handles: Declaring and initializing the GDT entries Installing the GDT Defining 16, 32 and 64-bit segments for kernel code/data Initialization flow 1. GDT structures The GDT is defined as a static array of descriptors in kernel/cpu/include/gdt.h . A pointer structure named gdt_ptr_t is passed to lgdt to load it in kernel/asm/gdt_flush.asm . // Source: kernel/cpu/include/gdt.h // The GDT descriptor structure typedef struct { uint16_t limit_low; uint16_t base_low; uint8_t base_middle; uint8_t access; uint8_t granularity; uint8_t base_high; } __attribute__ ((packed)) gdt_entry_t; // The GDT pointer structure typedef struct { uint16_t limit; uint64_t base; } __attribute__ ((packed)) gdt_ptr_t; 2. Initialization function NOTE: the functions described below depend of the gdt array. The GDT is initialized using the gdt_init() function declared in kernel/cpu/include/gdt.h . This function is defined in kernel/cpu/gdt.c . First, it sets up the GDT pointer (defined as gdt_ptr ) and then, it sets up the GDT entries with the gdt_set_entry() static function defined in kernel/cpu/gdt.c like the following: // Source: kernel/cpu/gdt.c static void gdt_set_entry(int n, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags) { // function body here } gdt_init() sets up the following segments: Null 16-bit code / 16-bit data 32-bit code / 32-bit data 64-bit code / 64-bit data Finally, it flushes the GDT using gdt_flush() defined in kernel/asm/gdt_flush.asm . ; Source: kernel/asm/gdt_flush.asm gdt_flush: lgdt [rdi] ; gdt_ptr is passed to RDI mov ax, 0x30 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax pop rdi mov ax, 0x28 push rax push rdi retfq ret","title":"GDT"},{"location":"cpu/gdt/#gdt-global-descriptor-table","text":"This page documents the internal implementation of the GDT setup in BenOS.","title":"GDT \u2013 Global Descriptor Table"},{"location":"cpu/gdt/#overview","text":"The GDT is initialized during early kernel boot to setup required segment descriptors in long mode. The segmentation is not really used in long mode, but the GDT is still required for compatibility and TSS loading.","title":"Overview"},{"location":"cpu/gdt/#related-files","text":"kernel/cpu/include.gdt.h kernel/cpu/gdt.c kernel/asm/gdt_flush.asm","title":"Related files:"},{"location":"cpu/gdt/#responsibilities","text":"The GDT setup code handles: Declaring and initializing the GDT entries Installing the GDT Defining 16, 32 and 64-bit segments for kernel code/data","title":"Responsibilities"},{"location":"cpu/gdt/#initialization-flow","text":"","title":"Initialization flow"},{"location":"cpu/gdt/#1-gdt-structures","text":"The GDT is defined as a static array of descriptors in kernel/cpu/include/gdt.h . A pointer structure named gdt_ptr_t is passed to lgdt to load it in kernel/asm/gdt_flush.asm . // Source: kernel/cpu/include/gdt.h // The GDT descriptor structure typedef struct { uint16_t limit_low; uint16_t base_low; uint8_t base_middle; uint8_t access; uint8_t granularity; uint8_t base_high; } __attribute__ ((packed)) gdt_entry_t; // The GDT pointer structure typedef struct { uint16_t limit; uint64_t base; } __attribute__ ((packed)) gdt_ptr_t;","title":"1. GDT structures"},{"location":"cpu/gdt/#2-initialization-function","text":"NOTE: the functions described below depend of the gdt array. The GDT is initialized using the gdt_init() function declared in kernel/cpu/include/gdt.h . This function is defined in kernel/cpu/gdt.c . First, it sets up the GDT pointer (defined as gdt_ptr ) and then, it sets up the GDT entries with the gdt_set_entry() static function defined in kernel/cpu/gdt.c like the following: // Source: kernel/cpu/gdt.c static void gdt_set_entry(int n, uint32_t base, uint32_t limit, uint8_t access, uint8_t flags) { // function body here } gdt_init() sets up the following segments: Null 16-bit code / 16-bit data 32-bit code / 32-bit data 64-bit code / 64-bit data Finally, it flushes the GDT using gdt_flush() defined in kernel/asm/gdt_flush.asm . ; Source: kernel/asm/gdt_flush.asm gdt_flush: lgdt [rdi] ; gdt_ptr is passed to RDI mov ax, 0x30 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax pop rdi mov ax, 0x28 push rax push rdi retfq ret","title":"2. Initialization function"},{"location":"cpu/interrupts/","text":"Interrupts \u2013 IDT and ISRs This document describes how the Interrupt Descriptor Table (IDT) and Interrupt Service Routines (ISRs) are implemented in BenOS. Overview The IDT is a CPU structure used to handle exceptions, hardware interrupts, and software traps. Each entry in the IDT points to an interrupt or exception handler function (ISR). It is loaded during early kernel initialization. Related files kernel/cpu/include/idt.h kernel/cpu/idt.c kernel/asm/idt_flush.asm kernel/cpu/include/interrupts.h kernel/cpu/interrupts.c kernel/cpu/isr.asm Responsibilities The IDT code is responsible for: Defining and populating the IDT entries Initializing exception handlers (0\u201331) Initializing hardware interrupt handlers (32\u201347) Loading the IDT NOTE: Actually, the exception handlers and hardware interrupt handlers are not complete. The IDT can handle: - General Protection Fault (#GP) - Page Fault (#PF) - Double Fault (#DF) - Division Error (#DE) - Invalid TSS (#TS) - IRQ 0 (PIT) - IRQ 1 (Keyboard) Initialization flow 1. IDT structures The IDT is defined as a static array of descriptors in kernel/cpu/include/idt.h . A pointer structure named idt_ptr_t is passed to lidt to load it in kernel/asm/idt_flush.asm . // Source: kernel/cpu/include/idt.h // The IDT descriptor structure typedef struct { uint16_t offset_low; uint16_t selector; uint8_t ist; uint8_t type_attribute; uint16_t offset_middle; uint32_t offset_high; uint32_t zero; } __attribute__ ((packed)) idt_entry_t; // The IDT pointer structure typedef struct { uint16_t limit; uint64_t base; } __attribute__ ((packed)) idt_ptr_t; 2. Initialization function NOTE: the functions described below depend of the idt array. The IDT is initialized using the idt_init() function declared in kernel/cpu/include/idt.h . This function is defined in kernel/cpu/idt.c . First, it sets up the IDT pointer (defined as idt_ptr ) and then, it sets up the IDT entries with the idt_set_entry() function defined in kernel/cpu/include/idt.h like the following: // Source: kernel/cpu/include/idt.h void idt_set_entry(int n, uint64_t base, uint16_t selector, uint8_t flags); After setting up all the IDT entries, idt_init() flushes the IDT using idt_flush() defined in kernel/asm/idt_flush.asm . ; Source: kernel/asm/idt_flush.asm idt_flush: mov rax, rdi lidt [rax] ret","title":"Interrupts"},{"location":"cpu/interrupts/#interrupts-idt-and-isrs","text":"This document describes how the Interrupt Descriptor Table (IDT) and Interrupt Service Routines (ISRs) are implemented in BenOS.","title":"Interrupts \u2013 IDT and ISRs"},{"location":"cpu/interrupts/#overview","text":"The IDT is a CPU structure used to handle exceptions, hardware interrupts, and software traps. Each entry in the IDT points to an interrupt or exception handler function (ISR). It is loaded during early kernel initialization.","title":"Overview"},{"location":"cpu/interrupts/#related-files","text":"kernel/cpu/include/idt.h kernel/cpu/idt.c kernel/asm/idt_flush.asm kernel/cpu/include/interrupts.h kernel/cpu/interrupts.c kernel/cpu/isr.asm","title":"Related files"},{"location":"cpu/interrupts/#responsibilities","text":"The IDT code is responsible for: Defining and populating the IDT entries Initializing exception handlers (0\u201331) Initializing hardware interrupt handlers (32\u201347) Loading the IDT NOTE: Actually, the exception handlers and hardware interrupt handlers are not complete. The IDT can handle: - General Protection Fault (#GP) - Page Fault (#PF) - Double Fault (#DF) - Division Error (#DE) - Invalid TSS (#TS) - IRQ 0 (PIT) - IRQ 1 (Keyboard)","title":"Responsibilities"},{"location":"cpu/interrupts/#initialization-flow","text":"","title":"Initialization flow"},{"location":"cpu/interrupts/#1-idt-structures","text":"The IDT is defined as a static array of descriptors in kernel/cpu/include/idt.h . A pointer structure named idt_ptr_t is passed to lidt to load it in kernel/asm/idt_flush.asm . // Source: kernel/cpu/include/idt.h // The IDT descriptor structure typedef struct { uint16_t offset_low; uint16_t selector; uint8_t ist; uint8_t type_attribute; uint16_t offset_middle; uint32_t offset_high; uint32_t zero; } __attribute__ ((packed)) idt_entry_t; // The IDT pointer structure typedef struct { uint16_t limit; uint64_t base; } __attribute__ ((packed)) idt_ptr_t;","title":"1. IDT structures"},{"location":"cpu/interrupts/#2-initialization-function","text":"NOTE: the functions described below depend of the idt array. The IDT is initialized using the idt_init() function declared in kernel/cpu/include/idt.h . This function is defined in kernel/cpu/idt.c . First, it sets up the IDT pointer (defined as idt_ptr ) and then, it sets up the IDT entries with the idt_set_entry() function defined in kernel/cpu/include/idt.h like the following: // Source: kernel/cpu/include/idt.h void idt_set_entry(int n, uint64_t base, uint16_t selector, uint8_t flags); After setting up all the IDT entries, idt_init() flushes the IDT using idt_flush() defined in kernel/asm/idt_flush.asm . ; Source: kernel/asm/idt_flush.asm idt_flush: mov rax, rdi lidt [rax] ret","title":"2. Initialization function"},{"location":"drivers/kbd/","text":"Keyboard driver Overview The keyboard driver handles input from the PS/2 keyboard, translates raw scancodes into ASCII characters, and keeps track of the current modifier state (Shift, Ctrl, AltGr). It relies on the PS/2 controller for low-level communication and uses IRQ1 to receive keyboard events. Related files kernel/drivers/include/kbd.h kernel/drivers/kbd.c Scancode handling The driver supports Set 1 scancodes (as configured by the PS/2 controller). Scancodes are read via port 0x60 . A key press sends a \u201cmake\u201d code. A key release sends a \u201cbreak\u201d code (make code + 0x80 ). Keymaps There are two lookup tables: keyboard_map_normal : standard ASCII for non-shifted keys. keyboard_map_shift : uppercase/symbols for when Shift is active. // Example: 'a' key keyboard_map_normal[0x1E] = 'a'; keyboard_map_shift[0x1E] = 'A'; Modifier keys The driver keeps track of: Shift ( K_LEFT_SHIFT , K_RIGHT_SHIFT ) Ctrl ( K_CTRL ) AltGr ( K_ALTGR ) Each of them toggles a flag (e.g., shift_pressed ), updated depending on whether the scancode is a make or break. Functions kbd_read_scancode() uint8_t kbd_read_scancode(); Reads the latest scancode from port 0x60 . kbd_scancode_to_char(uint8_t scancode) char kbd_scancode_to_char(uint8_t scancode); Takes a scancode (from kbd_read_scancode() ). Updates modifier key states. Returns the corresponding ASCII character, or 0 if: It was a modifier key It's a break code It's an unrecognized key Dependencies PS/2 controller : receives raw scancodes via IRQ1 I/O ports : read scancodes from 0x60 PIC : IRQ1 routing Console (if output is needed elsewhere) Notes The driver does not include a key buffer (FIFO) or blocking getchar() yet.","title":"Keyboard"},{"location":"drivers/kbd/#keyboard-driver","text":"","title":"Keyboard driver"},{"location":"drivers/kbd/#overview","text":"The keyboard driver handles input from the PS/2 keyboard, translates raw scancodes into ASCII characters, and keeps track of the current modifier state (Shift, Ctrl, AltGr). It relies on the PS/2 controller for low-level communication and uses IRQ1 to receive keyboard events.","title":"Overview"},{"location":"drivers/kbd/#related-files","text":"kernel/drivers/include/kbd.h kernel/drivers/kbd.c","title":"Related files"},{"location":"drivers/kbd/#scancode-handling","text":"The driver supports Set 1 scancodes (as configured by the PS/2 controller). Scancodes are read via port 0x60 . A key press sends a \u201cmake\u201d code. A key release sends a \u201cbreak\u201d code (make code + 0x80 ).","title":"Scancode handling"},{"location":"drivers/kbd/#keymaps","text":"There are two lookup tables: keyboard_map_normal : standard ASCII for non-shifted keys. keyboard_map_shift : uppercase/symbols for when Shift is active. // Example: 'a' key keyboard_map_normal[0x1E] = 'a'; keyboard_map_shift[0x1E] = 'A';","title":"Keymaps"},{"location":"drivers/kbd/#modifier-keys","text":"The driver keeps track of: Shift ( K_LEFT_SHIFT , K_RIGHT_SHIFT ) Ctrl ( K_CTRL ) AltGr ( K_ALTGR ) Each of them toggles a flag (e.g., shift_pressed ), updated depending on whether the scancode is a make or break.","title":"Modifier keys"},{"location":"drivers/kbd/#functions","text":"","title":"Functions"},{"location":"drivers/kbd/#kbd_read_scancode","text":"uint8_t kbd_read_scancode(); Reads the latest scancode from port 0x60 .","title":"kbd_read_scancode()"},{"location":"drivers/kbd/#kbd_scancode_to_charuint8_t-scancode","text":"char kbd_scancode_to_char(uint8_t scancode); Takes a scancode (from kbd_read_scancode() ). Updates modifier key states. Returns the corresponding ASCII character, or 0 if: It was a modifier key It's a break code It's an unrecognized key","title":"kbd_scancode_to_char(uint8_t scancode)"},{"location":"drivers/kbd/#dependencies","text":"PS/2 controller : receives raw scancodes via IRQ1 I/O ports : read scancodes from 0x60 PIC : IRQ1 routing Console (if output is needed elsewhere)","title":"Dependencies"},{"location":"drivers/kbd/#notes","text":"The driver does not include a key buffer (FIFO) or blocking getchar() yet.","title":"Notes"},{"location":"drivers/pic/","text":"PIC - Programmable Interrupt Controller Overview The Programmable Interrupt Controller (PIC) is responsible for handling hardware interrupts in the system. The x86 architecture traditionally uses two cascaded PICs (Master and Slave), which need to be properly initialized and managed. In BenOS, the PIC driver provides functions to remap, enable/disable, and query the PIC state. It also allows masking or unmasking specific IRQ lines. Related files kernel/drivers/include/pic.h kernel/drivers/pic.c Core functions void pic_send_eoi(uint8_t irq); Sends an End of Interrupt (EOI) command to the PIC after handling an IRQ. void pic_remap(int offset1, int offset2); Remaps the PIC interrupts to new vector offsets to avoid conflicts with CPU exceptions. void pic_disable(); Disables all IRQs by masking every line. void irq_set_mask(uint8_t irqline); Masks (disables) a specific IRQ line. void irq_clear_mask(uint8_t irqline); Unmasks (enables) a specific IRQ line. uint16_t pic_get_irr(); Returns the current value of the Interrupt Request Register (IRR). uint16_t pic_get_isr(); Returns the current value of the In-Service Register (ISR).","title":"PIC"},{"location":"drivers/pic/#pic-programmable-interrupt-controller","text":"","title":"PIC - Programmable Interrupt Controller"},{"location":"drivers/pic/#overview","text":"The Programmable Interrupt Controller (PIC) is responsible for handling hardware interrupts in the system. The x86 architecture traditionally uses two cascaded PICs (Master and Slave), which need to be properly initialized and managed. In BenOS, the PIC driver provides functions to remap, enable/disable, and query the PIC state. It also allows masking or unmasking specific IRQ lines.","title":"Overview"},{"location":"drivers/pic/#related-files","text":"kernel/drivers/include/pic.h kernel/drivers/pic.c","title":"Related files"},{"location":"drivers/pic/#core-functions","text":"void pic_send_eoi(uint8_t irq); Sends an End of Interrupt (EOI) command to the PIC after handling an IRQ. void pic_remap(int offset1, int offset2); Remaps the PIC interrupts to new vector offsets to avoid conflicts with CPU exceptions. void pic_disable(); Disables all IRQs by masking every line. void irq_set_mask(uint8_t irqline); Masks (disables) a specific IRQ line. void irq_clear_mask(uint8_t irqline); Unmasks (enables) a specific IRQ line. uint16_t pic_get_irr(); Returns the current value of the Interrupt Request Register (IRR). uint16_t pic_get_isr(); Returns the current value of the In-Service Register (ISR).","title":"Core functions"},{"location":"drivers/pit/","text":"PIT - Programmable Interval Timer Overview The PIT (Programmable Interval Timer) is a hardware timer used in x86 systems to generate interrupts at regular intervals. It plays a key role in OS timekeeping and task scheduling. In BenOS, the PIT is initialized with a specified frequency to trigger periodic interrupts, which are then handled by the system timer. Related files kernel/drivers/include/timer.h kernel/drivers/timer.c Constants These values are typically used to configure the PIT: - Command port: 0x43 - Channel 0 data port: 0x40 - Default frequency: 1193180 Hz (hardware constant of the PIT) Functions void pit_init(uint64_t frequency); Initializes the PIT to the specified frequency (in Hz). It computes the divisor from the base frequency (1193180 Hz), then sends the configuration and divisor to the PIT. Example pit_init(100); // Initializes the PIT to 100 Hz (every 10ms)","title":"PIT"},{"location":"drivers/pit/#pit-programmable-interval-timer","text":"","title":"PIT - Programmable Interval Timer"},{"location":"drivers/pit/#overview","text":"The PIT (Programmable Interval Timer) is a hardware timer used in x86 systems to generate interrupts at regular intervals. It plays a key role in OS timekeeping and task scheduling. In BenOS, the PIT is initialized with a specified frequency to trigger periodic interrupts, which are then handled by the system timer.","title":"Overview"},{"location":"drivers/pit/#related-files","text":"kernel/drivers/include/timer.h kernel/drivers/timer.c","title":"Related files"},{"location":"drivers/pit/#constants","text":"These values are typically used to configure the PIT: - Command port: 0x43 - Channel 0 data port: 0x40 - Default frequency: 1193180 Hz (hardware constant of the PIT)","title":"Constants"},{"location":"drivers/pit/#functions","text":"void pit_init(uint64_t frequency); Initializes the PIT to the specified frequency (in Hz). It computes the divisor from the base frequency (1193180 Hz), then sends the configuration and divisor to the PIT.","title":"Functions"},{"location":"drivers/pit/#example","text":"pit_init(100); // Initializes the PIT to 100 Hz (every 10ms)","title":"Example"},{"location":"drivers/ps2kbd/","text":"The PS/2 keyboard driver Overview The PS/2 Controller (often called the \u201cKeyboard controller\u201d) is located on the mainboard. In the early days the controller was a single chip (Intel 8042). (Source: https://wiki.osdev.org/I8042_PS/2_Controller) In BenOS, the PS/2 driver is used to initialize and manage the PS/2 Controller, which is necessary to make the keyboard driver work properly. Related files kernel/drivers/include/ps2.h kernel/drivers/ps2.c Constants All these constants are defined in kernel/drivers/include/ps2.h . Name Value Description KBD_DATA 0x60 Data port used for commands and responses KBD_STATUS_OBF Bit Output Buffer Full \u2013 set when data is ready to be read KBD_STATUS_IBF Bit Input Buffer Full \u2013 set when controller is processing KBD_DISABLE_PORT1 Byte Command to disable the first PS/2 port KBD_ENABLE_PORT1 Byte Command to enable the first PS/2 port KBD_READ_CONF Byte Command to read the controller configuration byte KBD_WRITE_CONF Byte Command to write to the controller configuration byte KBD_SELF_TEST Byte Command to run a self-test of the controller Initialization flow The initialization sequence involves: Disabling the first PS/2 port Flushing the output buffer Reading and editing the controller configuration byte Performing the controller self-test Reseting the keyboard Setting the keyboard scancode set I/O synchronization The two static functions used for I/O synchronization are: // Source: kernel/drivers/ps2.c static void wait_ibf_clear(); // Wait for the input buffer to be clear static void wait_obf_full(); // Wait for the output buffer to be full Core functions There are two core functions, but the first one is used nowhere in the kernel. It is just here because it could be useful for the future. // Source: kernel/drivers/include/ps2.h void ps2_set_typematic_rate(uint8_t rate); void ps2_controller_init(); So ps2_set_typematic_rate() is not used yet. It modifies the typematic rate (in Hz). The most important function of this driver is the second one: ps2_controller_init() . Check the initialization flow to see what it exactly does. Error handling and warnings Here are the different handled errors and warnings you can get: ps2_set_typematic_rate() [WARN] Failed to set typematic on PS/2 controller This warning may occur if the controller doesn't support typematic rate configuration or is unresponsive. [WARN] Bad configuration setting for PS/2 controller This indicates an invalid response was received after attempting to set the typematic rate. ps2_controller_init() [ERR] PS/2 controller self test failed The controller returned an unexpected result during its self-test. [ERR] Failed to reset the PS/2 keyboard The keyboard did not acknowledge the reset command. [WARN] Keyboard didn't acknowledge 0xF0 The keyboard did not acknowledge the 0xF0 command (used to set scancode mode). [WARN] Keyboard didn't accept Scancode Set 1 The keyboard rejected the requested scancode set. It may still work using the default set (likely 2 or 3).","title":"PS/2 keyboard"},{"location":"drivers/ps2kbd/#the-ps2-keyboard-driver","text":"","title":"The PS/2 keyboard driver"},{"location":"drivers/ps2kbd/#overview","text":"The PS/2 Controller (often called the \u201cKeyboard controller\u201d) is located on the mainboard. In the early days the controller was a single chip (Intel 8042). (Source: https://wiki.osdev.org/I8042_PS/2_Controller) In BenOS, the PS/2 driver is used to initialize and manage the PS/2 Controller, which is necessary to make the keyboard driver work properly.","title":"Overview"},{"location":"drivers/ps2kbd/#related-files","text":"kernel/drivers/include/ps2.h kernel/drivers/ps2.c","title":"Related files"},{"location":"drivers/ps2kbd/#constants","text":"All these constants are defined in kernel/drivers/include/ps2.h . Name Value Description KBD_DATA 0x60 Data port used for commands and responses KBD_STATUS_OBF Bit Output Buffer Full \u2013 set when data is ready to be read KBD_STATUS_IBF Bit Input Buffer Full \u2013 set when controller is processing KBD_DISABLE_PORT1 Byte Command to disable the first PS/2 port KBD_ENABLE_PORT1 Byte Command to enable the first PS/2 port KBD_READ_CONF Byte Command to read the controller configuration byte KBD_WRITE_CONF Byte Command to write to the controller configuration byte KBD_SELF_TEST Byte Command to run a self-test of the controller","title":"Constants"},{"location":"drivers/ps2kbd/#initialization-flow","text":"The initialization sequence involves: Disabling the first PS/2 port Flushing the output buffer Reading and editing the controller configuration byte Performing the controller self-test Reseting the keyboard Setting the keyboard scancode set","title":"Initialization flow"},{"location":"drivers/ps2kbd/#io-synchronization","text":"The two static functions used for I/O synchronization are: // Source: kernel/drivers/ps2.c static void wait_ibf_clear(); // Wait for the input buffer to be clear static void wait_obf_full(); // Wait for the output buffer to be full","title":"I/O synchronization"},{"location":"drivers/ps2kbd/#core-functions","text":"There are two core functions, but the first one is used nowhere in the kernel. It is just here because it could be useful for the future. // Source: kernel/drivers/include/ps2.h void ps2_set_typematic_rate(uint8_t rate); void ps2_controller_init(); So ps2_set_typematic_rate() is not used yet. It modifies the typematic rate (in Hz). The most important function of this driver is the second one: ps2_controller_init() . Check the initialization flow to see what it exactly does.","title":"Core functions"},{"location":"drivers/ps2kbd/#error-handling-and-warnings","text":"Here are the different handled errors and warnings you can get:","title":"Error handling and warnings"},{"location":"drivers/ps2kbd/#ps2_set_typematic_rate","text":"[WARN] Failed to set typematic on PS/2 controller This warning may occur if the controller doesn't support typematic rate configuration or is unresponsive. [WARN] Bad configuration setting for PS/2 controller This indicates an invalid response was received after attempting to set the typematic rate.","title":"ps2_set_typematic_rate()"},{"location":"drivers/ps2kbd/#ps2_controller_init","text":"[ERR] PS/2 controller self test failed The controller returned an unexpected result during its self-test. [ERR] Failed to reset the PS/2 keyboard The keyboard did not acknowledge the reset command. [WARN] Keyboard didn't acknowledge 0xF0 The keyboard did not acknowledge the 0xF0 command (used to set scancode mode). [WARN] Keyboard didn't accept Scancode Set 1 The keyboard rejected the requested scancode set. It may still work using the default set (likely 2 or 3).","title":"ps2_controller_init()"}]}